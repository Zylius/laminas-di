{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-di üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" laminas-di provides autowiring to implement Inversion of Control (IoC) containers. IoC containers are widely used to create object instances that have all dependencies resolved and injected. Dependency Injection containers are one form of IoC ‚Äì but not the only form. laminas-di is designed to be simple, fast and reusable. It provides the following features: Constructor injection Autowiring: Recursively through all dependencies With configured type preferences with configured injections With injections passed in the create() call Code generators to create factories usable by other IoC containers like Laminas\\ServiceManager It does not provide: Setter, interface, property or any other injection method than constructor injection Support for factories Declaring shared/unshared instances the injector always creates new instances the default container always shares instances Support for variadic arguments in __construct If you need these features combine it with another IoC container such as laminas-servicemanager . File issues at https://github.com/laminas/laminas-di/issues Documentation is at https://docs.laminas.dev/laminas-di/","title":"Home"},{"location":"#laminas-di","text":"","title":"laminas-di"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" laminas-di provides autowiring to implement Inversion of Control (IoC) containers. IoC containers are widely used to create object instances that have all dependencies resolved and injected. Dependency Injection containers are one form of IoC ‚Äì but not the only form. laminas-di is designed to be simple, fast and reusable. It provides the following features: Constructor injection Autowiring: Recursively through all dependencies With configured type preferences with configured injections With injections passed in the create() call Code generators to create factories usable by other IoC containers like Laminas\\ServiceManager It does not provide: Setter, interface, property or any other injection method than constructor injection Support for factories Declaring shared/unshared instances the injector always creates new instances the default container always shares instances Support for variadic arguments in __construct If you need these features combine it with another IoC container such as laminas-servicemanager . File issues at https://github.com/laminas/laminas-di/issues Documentation is at https://docs.laminas.dev/laminas-di/","title":"üá∫üá∏ To Citizens of Russia"},{"location":"v2/config/","text":"Configuration Most of the configuration for both the setup of Definition s as well as the setup of the InstanceManager can be attained by a configuration file. This file will produce an array (typically) and have an iterable structure. The top two keys are 'definition' and 'instance', each specifying values for the definition setup and instance manager setup, respectively. The definition section expects the following information expressed as a PHP array: $config = [ 'definition' =&gt; [ 'compiler' =&gt; [/* @todo compiler information */], 'runtime' =&gt; [/* @todo runtime information */], 'class' =&gt; [ 'instantiator' =&gt; '', // the name of the instantiator, by default this is __construct 'supertypes' =&gt; [], // an array of supertypes the class implements 'methods' =&gt; [ 'setSomeParameter' =&gt; [ // a method name 'parameterName' =&gt; [ 'name', // string parameter name 'type', // type or null 'is-required', // bool ], ], ], ], ], ];","title":"Configuration"},{"location":"v2/config/#configuration","text":"Most of the configuration for both the setup of Definition s as well as the setup of the InstanceManager can be attained by a configuration file. This file will produce an array (typically) and have an iterable structure. The top two keys are 'definition' and 'instance', each specifying values for the definition setup and instance manager setup, respectively. The definition section expects the following information expressed as a PHP array: $config = [ 'definition' =&gt; [ 'compiler' =&gt; [/* @todo compiler information */], 'runtime' =&gt; [/* @todo runtime information */], 'class' =&gt; [ 'instantiator' =&gt; '', // the name of the instantiator, by default this is __construct 'supertypes' =&gt; [], // an array of supertypes the class implements 'methods' =&gt; [ 'setSomeParameter' =&gt; [ // a method name 'parameterName' =&gt; [ 'name', // string parameter name 'type', // type or null 'is-required', // bool ], ], ], ], ], ];","title":"Configuration"},{"location":"v2/debugging-and-complex-use-cases/","text":"Debugging &amp; Complex Use Cases Debugging a DiC It is possible to dump the information contained within both the Definition and InstanceManager for a Laminas\\Di\\Di instance. The easiest way is to do the following: Laminas\\Di\\Display\\Console::export($di); If you are using a RuntimeDefinition where upon you expect a particular definition to be resolve at the first-call, you can see that information to the console display to force it to read that class: Laminas\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']); Complex Use Cases Interface Injection namespace Foo\\Bar { class Baz implements BamAwareInterface { public $bam; public function setBam(Bam $bam) { $this-&gt;bam = $bam; } } class Bam { } interface BamAwareInterface { public function setBam(Bam $bam); } } namespace { include 'laminasbootstrap.php'; $di = new Laminas\\Di\\Di; $baz = $di-&gt;get('Foo\\Bar\\Baz'); } Setter Injection with Class Definition namespace Foo\\Bar { class Baz { public $bam; public function setBam(Bam $bam) { $this-&gt;bam = $bam; } } class Bam { } } namespace { $di = new Laminas\\Di\\Di; $di-&gt;configure(new Laminas\\Di\\Config([ 'definition' =&gt; [ 'class' =&gt; [ 'Foo\\Bar\\Baz' =&gt; [ 'setBam' =&gt; ['required' =&gt; true], ], ], ], ])); $baz = $di-&gt;get('Foo\\Bar\\Baz'); } Multiple Injections To A Single Injection Point namespace Application { class Page { public $blocks; public function addBlock(Block $block) { $this-&gt;blocks[] = $block; } } interface Block { } } namespace MyModule { class BlockOne implements \\Application\\Block {} class BlockTwo implements \\Application\\Block {} } namespace { include 'laminasbootstrap.php'; $di = new Laminas\\Di\\Di; $di-&gt;configure(new Laminas\\Di\\Config([ 'definition' =&gt; [ 'class' =&gt; [ 'Application\\Page' =&gt; [ 'addBlock' =&gt; [ 'block' =&gt; [ 'type' =&gt; 'Application\\Block', 'required' =&gt; true, ], ], ], ], ], 'instance' =&gt; [ 'Application\\Page' =&gt; [ 'injections' =&gt; [ 'MyModule\\BlockOne', 'MyModule\\BlockTwo', ], ], ], ])); $page = $di-&gt;get('Application\\Page'); }","title":"Debugging And Complex Use Cases"},{"location":"v2/debugging-and-complex-use-cases/#debugging-complex-use-cases","text":"","title":"Debugging &amp; Complex Use Cases"},{"location":"v2/debugging-and-complex-use-cases/#debugging-a-dic","text":"It is possible to dump the information contained within both the Definition and InstanceManager for a Laminas\\Di\\Di instance. The easiest way is to do the following: Laminas\\Di\\Display\\Console::export($di); If you are using a RuntimeDefinition where upon you expect a particular definition to be resolve at the first-call, you can see that information to the console display to force it to read that class: Laminas\\Di\\Display\\Console::export($di, ['A\\ClassIWantTo\\GetTheDefinitionFor']);","title":"Debugging a DiC"},{"location":"v2/debugging-and-complex-use-cases/#complex-use-cases","text":"","title":"Complex Use Cases"},{"location":"v2/definitions/","text":"Dependency Definitions Definitions are what laminas-di uses to understand the structure of the code it is attempting to wire. This means that if you've written non-ambiguous, clear, and concise code, laminas-di has a very good chance of understanding how to wire things up without much added complexity. DefinitionList Definitions are introduced to the Laminas\\Di\\Di object through a definition list implemented as Laminas\\Di\\DefinitionList (which extends SplDoublyLinkedList ). Order is important. Definitions in the front of the list will be consulted on a class before definitions at the end of the list. Autoloading Regardless of what kind of DefinitionList strategy you decide to use, it is important that your autoloaders are already setup and ready to use. RuntimeDefinition The default DefinitionList instantiated by Laminas\\Di\\Di when no other DefinitionList is provided is Laminas\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition will respond to queries about classes by using PHP's Reflection API. The RuntimeDefinition uses any available information inside methods ‚Äî including their signature, the names of parameters, the type-hints of the parameters, and the default values ‚Äî to determine if something is optional or required when making a call to that method. The more explicit you can be in your method naming and method signatures, the more likely Laminas\\Di\\Definition\\RuntimeDefinition will accurately understand the structure of your code. The constructor of RuntimeDefinition looks like the following: public function __construct( IntrospectionStrategy $introspectionStrategy = null, array $explicitClasses = null ) { $this-&gt;introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy(); if ($explicitClasses) { $this-&gt;setExplicitClasses($explicitClasses); } } The IntrospectionStrategy object is an object that defines the rules by which the RuntimeDefinition will introspect information about your classes. Here are the things it knows how to do: Whether or not to use annotations (scanning and parsing annotations is expensive, and thus disabled by default). Which method names to include in the introspection; this is a list of patterns. By default, it registers the pattern /^set\\[A-Z\\]{1}\\\\w\\*/ . Which interface names represent the interface injection pattern; this is a list of patterns. By default, the pattern /\\\\w\\*Aware\\\\w\\*/ is registered. The constructor for the IntrospectionStrategy looks like this: public function __construct(AnnotationManager $annotationManager = null) { $this-&gt;annotationManager = $annotationManager ?: $this-&gt;createDefaultAnnotationManager(); } The AnnotationManager is not required. If you wish to create a special AnnotationManager with your own annotations, and also wish to extend the RuntimeDefinition to look for those annotations, this is the place to do it. The RuntimeDefinition also can be used to look up either all classes (implicitly, which is default), or explicitly look up for particular pre-defined classes. This is useful when your strategy for inspecting one set of classes might differ from those of another strategy for another set of classes. This can be achieved by using the setExplicitClasses() method or by passing a list of classes as the second constructor argument of the RuntimeDefinition . CompilerDefinition The CompilerDefinition is similar in nature to the RuntimeDefinition with the exception that it can be seeded with more information for the purposes of \"compiling\" a definition. Compiled definitions eliminate reflection calls and annotation scannning, which can be a performance bottleneck in your production applications. For example, let's assume we want to create a script that will create definitions for some of our library code: // in \"package name\" format $components = [ 'My_MovieApp', 'My_OtherClasses', ]; foreach ($components as $component) { $diCompiler = new Laminas\\Di\\Definition\\CompilerDefinition; $diCompiler-&gt;addDirectory('/path/to/classes/' . str_replace('_', '/', $component)); $diCompiler-&gt;compile(); file_put_contents( __DIR__ . '/../data/di/' . $component . '-definition.php', '&lt;?php return ' . var_export($diCompiler-&gt;toArrayDefinition()-&gt;toArray(), true) . ';' ); } The above creates a file for each \"package\", containing the full definition for the classes defined for each. To utilize this in an application, use the following: protected function setupDi(Application $app) { $definitionList = new DefinitionList([ new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_MovieApp-definition.php'), new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_OtherClasses-definition.php'), $runtime = new Definition\\RuntimeDefinition(), ]); $di = new Di($definitionList, null, new Config($this-&gt;config-&gt;di)); $di-&gt;instanceManager()-&gt;addTypePreference('Laminas\\Di\\LocatorInterface', $di); $app-&gt;setLocator($di); } The above code would more than likely go inside your application's bootstrap or within a Module class. This represents the simplest and most performant way of configuring your DiC for usage. ClassDefinition The idea behind using a ClassDefinition is two-fold. First, you may want to override some information inside of a RuntimeDefinition . Secondly, you might want to simply define your complete class's definition with an xml, ini, or php file describing the structure. This class definition can be fed in via Configuration or by directly instantiating and registering the Definition with the DefinitionList .","title":"Dependency Definitions"},{"location":"v2/definitions/#dependency-definitions","text":"Definitions are what laminas-di uses to understand the structure of the code it is attempting to wire. This means that if you've written non-ambiguous, clear, and concise code, laminas-di has a very good chance of understanding how to wire things up without much added complexity.","title":"Dependency Definitions"},{"location":"v2/definitions/#definitionlist","text":"Definitions are introduced to the Laminas\\Di\\Di object through a definition list implemented as Laminas\\Di\\DefinitionList (which extends SplDoublyLinkedList ). Order is important. Definitions in the front of the list will be consulted on a class before definitions at the end of the list.","title":"DefinitionList"},{"location":"v2/definitions/#runtimedefinition","text":"The default DefinitionList instantiated by Laminas\\Di\\Di when no other DefinitionList is provided is Laminas\\Di\\Definition\\RuntimeDefinition . The RuntimeDefinition will respond to queries about classes by using PHP's Reflection API. The RuntimeDefinition uses any available information inside methods ‚Äî including their signature, the names of parameters, the type-hints of the parameters, and the default values ‚Äî to determine if something is optional or required when making a call to that method. The more explicit you can be in your method naming and method signatures, the more likely Laminas\\Di\\Definition\\RuntimeDefinition will accurately understand the structure of your code. The constructor of RuntimeDefinition looks like the following: public function __construct( IntrospectionStrategy $introspectionStrategy = null, array $explicitClasses = null ) { $this-&gt;introspectionStrategy = $introspectionStrategy ?: new IntrospectionStrategy(); if ($explicitClasses) { $this-&gt;setExplicitClasses($explicitClasses); } } The IntrospectionStrategy object is an object that defines the rules by which the RuntimeDefinition will introspect information about your classes. Here are the things it knows how to do: Whether or not to use annotations (scanning and parsing annotations is expensive, and thus disabled by default). Which method names to include in the introspection; this is a list of patterns. By default, it registers the pattern /^set\\[A-Z\\]{1}\\\\w\\*/ . Which interface names represent the interface injection pattern; this is a list of patterns. By default, the pattern /\\\\w\\*Aware\\\\w\\*/ is registered. The constructor for the IntrospectionStrategy looks like this: public function __construct(AnnotationManager $annotationManager = null) { $this-&gt;annotationManager = $annotationManager ?: $this-&gt;createDefaultAnnotationManager(); } The AnnotationManager is not required. If you wish to create a special AnnotationManager with your own annotations, and also wish to extend the RuntimeDefinition to look for those annotations, this is the place to do it. The RuntimeDefinition also can be used to look up either all classes (implicitly, which is default), or explicitly look up for particular pre-defined classes. This is useful when your strategy for inspecting one set of classes might differ from those of another strategy for another set of classes. This can be achieved by using the setExplicitClasses() method or by passing a list of classes as the second constructor argument of the RuntimeDefinition .","title":"RuntimeDefinition"},{"location":"v2/definitions/#compilerdefinition","text":"The CompilerDefinition is similar in nature to the RuntimeDefinition with the exception that it can be seeded with more information for the purposes of \"compiling\" a definition. Compiled definitions eliminate reflection calls and annotation scannning, which can be a performance bottleneck in your production applications. For example, let's assume we want to create a script that will create definitions for some of our library code: // in \"package name\" format $components = [ 'My_MovieApp', 'My_OtherClasses', ]; foreach ($components as $component) { $diCompiler = new Laminas\\Di\\Definition\\CompilerDefinition; $diCompiler-&gt;addDirectory('/path/to/classes/' . str_replace('_', '/', $component)); $diCompiler-&gt;compile(); file_put_contents( __DIR__ . '/../data/di/' . $component . '-definition.php', '&lt;?php return ' . var_export($diCompiler-&gt;toArrayDefinition()-&gt;toArray(), true) . ';' ); } The above creates a file for each \"package\", containing the full definition for the classes defined for each. To utilize this in an application, use the following: protected function setupDi(Application $app) { $definitionList = new DefinitionList([ new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_MovieApp-definition.php'), new Definition\\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_OtherClasses-definition.php'), $runtime = new Definition\\RuntimeDefinition(), ]); $di = new Di($definitionList, null, new Config($this-&gt;config-&gt;di)); $di-&gt;instanceManager()-&gt;addTypePreference('Laminas\\Di\\LocatorInterface', $di); $app-&gt;setLocator($di); } The above code would more than likely go inside your application's bootstrap or within a Module class. This represents the simplest and most performant way of configuring your DiC for usage.","title":"CompilerDefinition"},{"location":"v2/definitions/#classdefinition","text":"The idea behind using a ClassDefinition is two-fold. First, you may want to override some information inside of a RuntimeDefinition . Secondly, you might want to simply define your complete class's definition with an xml, ini, or php file describing the structure. This class definition can be fed in via Configuration or by directly instantiating and registering the Definition with the DefinitionList .","title":"ClassDefinition"},{"location":"v2/instance-manager/","text":"Instance Manager The InstanceManager is responsible for any runtime information associated with the laminas-di DiC. This means that the information that goes into the instance manager is specific to both how the particular consuming application's needs, and even more specifically to the environment in which the application is running. Parameters Parameters are simply entry points for either dependencies or instance configuration values. A class consists of a set of parameters, each uniquely named. When writing your classes, you should attempt to not use the same parameter name twice in the same class when you expect that that parameters is used for either instance configuration or an object dependency. This leads to an ambiguous parameter, and is a situation best avoided. Our movie finder example can be further used to explain these concepts: namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this-&gt;username = $username; $this-&gt;password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } In the above example, the class DbAdapter has 2 parameters: username and password ; MovieFinder has one parameter: dbAdapter ; and MovieLister has one parameter: movieFinder . Any of these can be utilized for injection of either dependencies or scalar values during instance configuration or during call time. When looking at the above code, since the $dbAdapter parameter and the $movieFinder parameter are both type-hinted with concrete types, the DiC can assume that it can fulfill these object tendencies by itself. On the other hand, $username and $password do not have type-hints and are, more than likely, scalar in nature. Since the DiC cannot reasonably know this information, it must be provided to the instance manager in the form of parameters. Not doing so will force $di-&gt;get('MyMovieApp\\\\MovieLister') to throw an exception. The following ways of using parameters are available: // Setting instance configuration into the instance manager: $di-&gt;instanceManager()-&gt;setParameters('MyLibrary\\DbAdapter', [ 'username' =&gt; 'myusername', 'password' =&gt; 'mypassword', ]); // Forcing a particular dependency to be used by the instance manager: $di-&gt;instanceManager()-&gt;setParameters('MyMovieApp\\MovieFinder', [ 'dbAdapter' =&gt; new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); // Passing instance parameters at call time: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password, ]); // Passing a specific instance at call time: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'dbAdapter' =&gt; new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); Preferences In many cases, you might be using interfaces as type hints as opposed to concrete types. Lets assume the movie example was modified in the following way: namespace MyMovieApp { interface MovieFinderInterface { // methods required for this type } class GenericMovieFinder implements MovieFinderInterface { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinderInterface $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } What you'll notice above is that the MovieLister type now expects that the dependency injected implements the MovieFinderInterface . This allows multiple implementations of this base interface to be used as a dependency, if that is what the consumer decides they want to do. As you can imagine, laminas-di, by itself would not be able to determine what kind of concrete object to use fulfill this dependency, so this type of \"preference\" needs to be made known to the instance manager. To give this information to the instance manager, see the following code example: $di-&gt;instanceManager()-&gt;addTypePreference( \\MyMovieApp\\MovieFinderInterface::class, \\MyMovieApp\\GenericMovieFinder::class ); // Assuming all instance config for username, password is setup: $di-&gt;get(\\MyMovieApp\\MovieLister::class); Aliases In some situations, you'll find that you need to alias an instance. There are two main reasons to do this. First, it creates a simpler, alternative name to use when using the DiC, as opposed to using the full class name. Second, you might find that you need to have the same object type in two separate contexts. This means that when you alias a particular class, you can then attach a specific instance configuration to that alias, as opposed to attaching that configuration to the class name. To demonstrate both of these points, we'll look at a use case where we'll have two separate database adapters. One will be for read-only operations, the other will be for read-write operations. Alias parameters Aliases can also have parameters registered at alias time. // Assume the MovieLister example of code from the quick start. $im = $di-&gt;instanceManager(); // add alias for short naming $im-&gt;addAlias('movielister', 'MyMovieApp\\MovieLister'); // add aliases for specific instances $im-&gt;addAlias('dbadapter-readonly', 'MyLibrary\\DbAdapter', [ 'username' =&gt; $config-&gt;db-&gt;readAdapter-&gt;username, 'password' =&gt; $config-&gt;db-&gt;readAdapter-&gt;password, ]); $im-&gt;addAlias('dbadapter-readwrite', 'MyLibrary\\DbAdapter', [ 'username' =&gt; $config-&gt;db-&gt;readWriteAdapter-&gt;username, 'password' =&gt; $config-&gt;db-&gt;readWriteAdapter-&gt;password, ]); // set a default type to use, pointing to an alias $im-&gt;addTypePreference('MyLibrary\\DbAdapter', 'dbadapter-readonly'); $movieListerRead = $di-&gt;get('MyMovieApp\\MovieLister'); $movieListerReadWrite = $di-&gt;get('MyMovieApp\\MovieLister', [ 'dbAdapter' =&gt; 'dbadapter-readwrite', ]);","title":"Instance Manager"},{"location":"v2/instance-manager/#instance-manager","text":"The InstanceManager is responsible for any runtime information associated with the laminas-di DiC. This means that the information that goes into the instance manager is specific to both how the particular consuming application's needs, and even more specifically to the environment in which the application is running.","title":"Instance Manager"},{"location":"v2/instance-manager/#parameters","text":"Parameters are simply entry points for either dependencies or instance configuration values. A class consists of a set of parameters, each uniquely named. When writing your classes, you should attempt to not use the same parameter name twice in the same class when you expect that that parameters is used for either instance configuration or an object dependency. This leads to an ambiguous parameter, and is a situation best avoided. Our movie finder example can be further used to explain these concepts: namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this-&gt;username = $username; $this-&gt;password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } In the above example, the class DbAdapter has 2 parameters: username and password ; MovieFinder has one parameter: dbAdapter ; and MovieLister has one parameter: movieFinder . Any of these can be utilized for injection of either dependencies or scalar values during instance configuration or during call time. When looking at the above code, since the $dbAdapter parameter and the $movieFinder parameter are both type-hinted with concrete types, the DiC can assume that it can fulfill these object tendencies by itself. On the other hand, $username and $password do not have type-hints and are, more than likely, scalar in nature. Since the DiC cannot reasonably know this information, it must be provided to the instance manager in the form of parameters. Not doing so will force $di-&gt;get('MyMovieApp\\\\MovieLister') to throw an exception. The following ways of using parameters are available: // Setting instance configuration into the instance manager: $di-&gt;instanceManager()-&gt;setParameters('MyLibrary\\DbAdapter', [ 'username' =&gt; 'myusername', 'password' =&gt; 'mypassword', ]); // Forcing a particular dependency to be used by the instance manager: $di-&gt;instanceManager()-&gt;setParameters('MyMovieApp\\MovieFinder', [ 'dbAdapter' =&gt; new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]); // Passing instance parameters at call time: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password, ]); // Passing a specific instance at call time: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'dbAdapter' =&gt; new MyLibrary\\DbAdapter('myusername', 'mypassword'), ]);","title":"Parameters"},{"location":"v2/instance-manager/#preferences","text":"In many cases, you might be using interfaces as type hints as opposed to concrete types. Lets assume the movie example was modified in the following way: namespace MyMovieApp { interface MovieFinderInterface { // methods required for this type } class GenericMovieFinder implements MovieFinderInterface { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinderInterface $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } What you'll notice above is that the MovieLister type now expects that the dependency injected implements the MovieFinderInterface . This allows multiple implementations of this base interface to be used as a dependency, if that is what the consumer decides they want to do. As you can imagine, laminas-di, by itself would not be able to determine what kind of concrete object to use fulfill this dependency, so this type of \"preference\" needs to be made known to the instance manager. To give this information to the instance manager, see the following code example: $di-&gt;instanceManager()-&gt;addTypePreference( \\MyMovieApp\\MovieFinderInterface::class, \\MyMovieApp\\GenericMovieFinder::class ); // Assuming all instance config for username, password is setup: $di-&gt;get(\\MyMovieApp\\MovieLister::class);","title":"Preferences"},{"location":"v2/instance-manager/#aliases","text":"In some situations, you'll find that you need to alias an instance. There are two main reasons to do this. First, it creates a simpler, alternative name to use when using the DiC, as opposed to using the full class name. Second, you might find that you need to have the same object type in two separate contexts. This means that when you alias a particular class, you can then attach a specific instance configuration to that alias, as opposed to attaching that configuration to the class name. To demonstrate both of these points, we'll look at a use case where we'll have two separate database adapters. One will be for read-only operations, the other will be for read-write operations.","title":"Aliases"},{"location":"v2/quick-start/","text":"Quick Start This quick start is intended to get developers familiar with the concepts of the laminas-di DiC. Generally speaking, code is never as simple as it is inside this example, so working knowledge of the other sections of the manual is suggested. Example Application Assume, for a moment, the following application code. It already assumes that dependencies are injected, and so becomes a good candiate for a DiC. namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this-&gt;username = $username; $this-&gt;password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } With the above code, you find yourself writing the following to wire and utilize it: // $config object is assumed $dbAdapter = new MyLibrary\\DbAdapter($config-&gt;username, $config-&gt;password); $movieFinder = new MyMovieApp\\MovieFinder($dbAdapter); $movieLister = new MyMovieApp\\MovieLister($movieFinder); foreach ($movieLister as $movie) { // iterate and display $movie } If you are doing this above wiring in each controller or view that wants to list movies, not only can this become repetitive and boring to write, but also unmaintainable if you want to swap out one of these dependencies on a wholesale scale. Since this example of code already practices good dependency injection using constructor injection, it is a great candidate for using laminas-di. Using a laminas-di Container The following demonstrates how to wire the above into a laminas-di container: // Inside a bootstrap somewhere $di = new Laminas\\Di\\Di(); $di-&gt;instanceManager()-&gt;setParameters('MyLibrary\\DbAdapter', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password, ]); // Elsewhere: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister'); foreach ($movieLister as $movie) { // iterate and display $movie } In the above example, we are obtaining a default instance of Laminas\\Di\\Di . By 'default', we mean that Laminas\\\\Di\\\\Di is constructed with a DefinitionList seeded with a RuntimeDefinition (which uses PHP's Reflection API) and an empty instance manager and no configuration: $di = new Laminas\\Di\\Di(); // is the same as $di = new Laminas\\Di\\Di( new Laminas\\Di\\DefinitionList(new Laminas\\Di\\Definition\\RuntimeDefinition()), new Laminas\\Di\\InstanceManager() ); This means that when $di-&gt;get() is called, it will be consulting the RuntimeDefinition , which uses Reflection to understand the structure of the code. Once it knows the structure of the code, it can then know how the dependencies fit together and how to go about wiring your objects for you. Laminas\\Di\\Definition\\RuntimeDefinition will utilize the names of the parameters in the methods as the class parameter names. This is how both the username and password keys are mapped to the first and second parameters, respectively, of the constructor consuming these named parameters. Passing Parameters on Call Time If you were to want to pass in the username and password at call time, this is achieved by passing them as the second argument to get() : $di = new Laminas\\Di\\Di(); $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password ]); foreach ($movieLister as $movie) { // iterate and display $movie } It is important to note that when using call time parameters, these parameter names will be applied to any class that accepts a parameter of such name. By calling $di-&gt;get() , this instance of MovieLister will be automatically shared. This means subsequent calls to get() will return the same instance as previous calls. If you wish to have completely new instances of MovieLister , you can utilize $di-&gt;newInstance() .","title":"Quick Start"},{"location":"v2/quick-start/#quick-start","text":"This quick start is intended to get developers familiar with the concepts of the laminas-di DiC. Generally speaking, code is never as simple as it is inside this example, so working knowledge of the other sections of the manual is suggested.","title":"Quick Start"},{"location":"v2/quick-start/#example-application","text":"Assume, for a moment, the following application code. It already assumes that dependencies are injected, and so becomes a good candiate for a DiC. namespace MyLibrary { class DbAdapter { protected $username = null; protected $password = null; public function __construct($username, $password) { $this-&gt;username = $username; $this-&gt;password = $password; } } } namespace MyMovieApp { class MovieFinder { protected $dbAdapter = null; public function __construct(\\MyLibrary\\DbAdapter $dbAdapter) { $this-&gt;dbAdapter = $dbAdapter; } } class MovieLister { protected $movieFinder = null; public function __construct(MovieFinder $movieFinder) { $this-&gt;movieFinder = $movieFinder; } } } With the above code, you find yourself writing the following to wire and utilize it: // $config object is assumed $dbAdapter = new MyLibrary\\DbAdapter($config-&gt;username, $config-&gt;password); $movieFinder = new MyMovieApp\\MovieFinder($dbAdapter); $movieLister = new MyMovieApp\\MovieLister($movieFinder); foreach ($movieLister as $movie) { // iterate and display $movie } If you are doing this above wiring in each controller or view that wants to list movies, not only can this become repetitive and boring to write, but also unmaintainable if you want to swap out one of these dependencies on a wholesale scale. Since this example of code already practices good dependency injection using constructor injection, it is a great candidate for using laminas-di.","title":"Example Application"},{"location":"v2/quick-start/#using-a-laminas-di-container","text":"The following demonstrates how to wire the above into a laminas-di container: // Inside a bootstrap somewhere $di = new Laminas\\Di\\Di(); $di-&gt;instanceManager()-&gt;setParameters('MyLibrary\\DbAdapter', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password, ]); // Elsewhere: $movieLister = $di-&gt;get('MyMovieApp\\MovieLister'); foreach ($movieLister as $movie) { // iterate and display $movie } In the above example, we are obtaining a default instance of Laminas\\Di\\Di . By 'default', we mean that Laminas\\\\Di\\\\Di is constructed with a DefinitionList seeded with a RuntimeDefinition (which uses PHP's Reflection API) and an empty instance manager and no configuration: $di = new Laminas\\Di\\Di(); // is the same as $di = new Laminas\\Di\\Di( new Laminas\\Di\\DefinitionList(new Laminas\\Di\\Definition\\RuntimeDefinition()), new Laminas\\Di\\InstanceManager() ); This means that when $di-&gt;get() is called, it will be consulting the RuntimeDefinition , which uses Reflection to understand the structure of the code. Once it knows the structure of the code, it can then know how the dependencies fit together and how to go about wiring your objects for you. Laminas\\Di\\Definition\\RuntimeDefinition will utilize the names of the parameters in the methods as the class parameter names. This is how both the username and password keys are mapped to the first and second parameters, respectively, of the constructor consuming these named parameters.","title":"Using a laminas-di Container"},{"location":"v2/quick-start/#passing-parameters-on-call-time","text":"If you were to want to pass in the username and password at call time, this is achieved by passing them as the second argument to get() : $di = new Laminas\\Di\\Di(); $movieLister = $di-&gt;get('MyMovieApp\\MovieLister', [ 'username' =&gt; $config-&gt;username, 'password' =&gt; $config-&gt;password ]); foreach ($movieLister as $movie) { // iterate and display $movie } It is important to note that when using call time parameters, these parameter names will be applied to any class that accepts a parameter of such name. By calling $di-&gt;get() , this instance of MovieLister will be automatically shared. This means subsequent calls to get() will return the same instance as previous calls. If you wish to have completely new instances of MovieLister , you can utilize $di-&gt;newInstance() .","title":"Passing Parameters on Call Time"},{"location":"v3/codegen/","text":"Code Generator laminas-di comes with Ahead-of-Time (AoT) generators to create optimized code for production. These generators will inspect the provided classes, resolve their dependencies, and generate factories based on these results. Removal of laminas-code dependencies Before version 3.1, this feature required laminas-code , which you can add to your project using Composer: $ composer require --dev laminas/laminas-code Since version 3.1 and up, this is no longer required. Generating an optimized injector The Laminas\\Di\\CodeGenerator\\InjectorGenerator class offers an implementation to generate an optimized injector based on the runtime configuration and a resolver instance. use Laminas\\Di\\Config; use Laminas\\Di\\Definition\\RuntimeDefinition; use Laminas\\Di\\Resolver\\DependencyResolver; use Laminas\\Di\\CodeGenerator\\InjectorGenerator; $config = new Config(); $resolver = new DependencyResolver(new RuntimeDefinition(), $config); $generator = new InjectorGenerator($config, $resolver); // It is highly recommended to set the container that is used at runtime: $resolver-&gt;setContainer($container); $generator-&gt;setOutputDirectory('/path/to/generated/files'); $generator-&gt;generate([ MyClassA::class, MyClassB::class, // ... ]); You can also utilize Laminas\\Code\\Scanner to scan your code for classes: $scanner = new DirectoryScanner(__DIR__); $generator-&gt;generate($scanner-&gt;getClassNames()); MVC and Mezzio integration When you are using laminas-di's ConfigProvider with Mezzio or consuming the Module class via laminas-mvc, you can obtain the generator instance from the service manager: $generator = $serviceManager-&gt;get(\\Laminas\\Di\\CodeGenerator\\InjectorGenerator::class); AoT Config Options The service factory uses options in your config service, located under the key dependencies.auto.aot . This should be defined as an associative array of options for creating the code generator instance. This array respects the following keys (unknown keys are ignored): namespace : This will be used as base namespace to prefix the namespace of the generated classes. It will be passed to the constructor of Laminas\\Di\\CodeGenerator\\InjectorGenerator ; the default value is Laminas\\Di\\Generated . directory : The directory where the generated PHP files will be stored. If this value is not provided, you will need to set it with the generator's setOutputDirectory() method before calling generate() . logger : must be resolvable in container and must be an instance of Psr\\Log\\LoggerInterface. By default Psr\\Log\\NullLogger is used. See the Logging section for details. Below is an example detailing configuration of the generator factory: return [ 'dependencies' =&gt; [ 'auto' =&gt; [ 'aot' =&gt; [ 'namespace' =&gt; 'AppAoT\\Generated', 'directory' =&gt; __DIR__ . '/../gen', 'logger' =&gt; Psr\\Log\\LoggerInterface::class, ], ], ], ]; Logging The InjectorGenerator allows passing a PSR-3 logger instance via an optional fourth constructor parameter. The generator will log the following information: When a factory is about to be generated for a class or alias (Log level: Debug) When the factory generation caused an exception (Log level: Error)","title":"Code Generator"},{"location":"v3/codegen/#code-generator","text":"laminas-di comes with Ahead-of-Time (AoT) generators to create optimized code for production. These generators will inspect the provided classes, resolve their dependencies, and generate factories based on these results.","title":"Code Generator"},{"location":"v3/codegen/#generating-an-optimized-injector","text":"The Laminas\\Di\\CodeGenerator\\InjectorGenerator class offers an implementation to generate an optimized injector based on the runtime configuration and a resolver instance. use Laminas\\Di\\Config; use Laminas\\Di\\Definition\\RuntimeDefinition; use Laminas\\Di\\Resolver\\DependencyResolver; use Laminas\\Di\\CodeGenerator\\InjectorGenerator; $config = new Config(); $resolver = new DependencyResolver(new RuntimeDefinition(), $config); $generator = new InjectorGenerator($config, $resolver); // It is highly recommended to set the container that is used at runtime: $resolver-&gt;setContainer($container); $generator-&gt;setOutputDirectory('/path/to/generated/files'); $generator-&gt;generate([ MyClassA::class, MyClassB::class, // ... ]); You can also utilize Laminas\\Code\\Scanner to scan your code for classes: $scanner = new DirectoryScanner(__DIR__); $generator-&gt;generate($scanner-&gt;getClassNames());","title":"Generating an optimized injector"},{"location":"v3/codegen/#mvc-and-mezzio-integration","text":"When you are using laminas-di's ConfigProvider with Mezzio or consuming the Module class via laminas-mvc, you can obtain the generator instance from the service manager: $generator = $serviceManager-&gt;get(\\Laminas\\Di\\CodeGenerator\\InjectorGenerator::class);","title":"MVC and Mezzio integration"},{"location":"v3/codegen/#logging","text":"The InjectorGenerator allows passing a PSR-3 logger instance via an optional fourth constructor parameter. The generator will log the following information: When a factory is about to be generated for a class or alias (Log level: Debug) When the factory generation caused an exception (Log level: Error)","title":"Logging"},{"location":"v3/config/","text":"Configuration Configuration detailing how types are constructed and dependencies should be resolved can be provided as an associative array when instantiating Laminas\\Di\\Config . A type may be an actual class name or an alias to a class name. The configuration array respects the following keys (unknown keys are ignored): preferences : Associative nested array that maps class or interface names to a service name that should be used to provide a dependency. See the Type Preferences section below for details. types : Associative array defining how classes or aliases should be constructed. Each key in this array is a class or alias name, and its value is another associative array with the following keys: preferences : The same as preferences above, but only for the associated class. parameters : Associative array declaring the values to inject for the declared construction parameters. Each key is the parameter name as declared in the constructor method of the associated class name. See the Parameters section below for details. typeOf : String that contains a class name. It declares that the associated key is an alias of the given class name. This class must exist. It cannot be another alias. Below is an example of injector configuration. $config = new \\Laminas\\Di\\Config([ // Declares global preferences to use when resolving // dependencies of the specified type 'preferences' =&gt; [ // A map of classname =&gt; preferred type MyInterface::class =&gt; MyImplementation::class, ], // Declares how types should be constructed. // This also allows declaring aliases of a specific class 'types' =&gt; [ ClassName::class =&gt; [ // Declaration in the same way as global preferences // but these will apply when the type of the associated key // should be instantiated 'preferences' =&gt; [], // Constructor parameters to inject. This option will define // the injections directly by the parameter name of the constructor // used as key. // // If the parameter is type-hinted by a class/interface name, you can // provide the injection by string. The injector will use the IoC // container to obtain it. 'parameters' =&gt; [ 'foo' =&gt; 'bar', ], ], // Define an alias 'Alias.Name' =&gt; [ 'typeOf' =&gt; ClassName::class, 'preferences' =&gt; [], 'parameters' =&gt; [], ], ], ]); Type Preferences In many cases, you might be using interfaces as type hints as opposed to concrete types. Even though type preferences are not limited to interfaces or abstract class names, they provide hints to the injector on how such types should be resolved. The resolver will look up the name finally passed to the container in the following way (the first match will be used): The preference defined in the type configuration of the class if it satifies the typehint (implements, extends, or typeOf). If there is a global preference defined and it satisfies the typehint. Use the typehinted name directly. // Assume the following classes are declared: interface FooInterface {} class Foo implements FooInterface {} class SpecialFoo implements FooInterface {} class Bar {} class MyClass { public function __construct(FooInterface $foo) { // ... } } // With the following configuration: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'preferences' =&gt; [ FooInterface::class =&gt; Foo::class, ], 'types' =&gt; [ 'MyClass.A' =&gt; [ 'typeOf' =&gt; MyClass::class, 'preferences' =&gt; [ FooInterface::class =&gt; SpecialFoo::class, ], ], 'MyClass.B' =&gt; [ 'typeOf' =&gt; MyClass::class, 'preferences' =&gt; [ FooInterface::class =&gt; Bar::class, ], ], ], ])); // The results are: $a = $injector-&gt;create(MyClass::class); // Constructed with Foo $b = $injector-&gt;create('MyClass.A'); // Constructed with SpecialFoo $c = $injector-&gt;create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface) Parameters In contrast to type preferences, the resolver will not perform checks if the provided value satisfies the required type. It will be used directly to inject the value. There are several ways to define injections. An IoC container service name as string: This is only possible if the required type is a class or interface. For other types (scalars, iterable , callable , etc) or typeless parameters, the string value is passed as is . An instance of Laminas\\Di\\Resolver\\ValueInjection : Injects the value returned by getValue() as is. An instance of Laminas\\Di\\Resolver\\TypeInjection : Obtains the injected value from the IoC container by passing the return value of getType() to the container's get() method. The string literal '*' : This requests the injector to ignore any previously defined parameter and use the type preference resolution as described in Type Preferences . Any other value will be used as is and encapsulated in a Laminas\\Di\\Resolver\\ValueInjection . If the provided value's type does not fit the required parameter type, an exception is thrown. Aliases Aliases allow you to configure the same class with different construction options. Aliases can directly be created with the injector or declared as type preferences. An alias must refer to an actual class or an interface, therefore you cannot declare aliases for another alias. For example the following class should be instantiated in two different ways: // Assume the following classes are declared: class Foo {} class SpecialFoo extends Foo {} class MyClass { public function __construct(Foo $foo, string $bar) { // ... } } // With the following injection config: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'types' =&gt; [ MyClass::class =&gt; [ 'parameters' =&gt; [ 'foo' =&gt; SpecialFoo::class, 'bar' =&gt; 'Stringvalue', ], ], 'MyClass.Alias' =&gt; [ 'typeOf' =&gt; MyClass::class, 'parameters' =&gt; [ 'foo' =&gt; '*', 'bar' =&gt; 'Stringvalue', ], ], ], ])); // The results are: $a = $injector-&gt;create(MyClass::class); // Constructed with SpecialFoo $b = $injector-&gt;create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)","title":"Configuration"},{"location":"v3/config/#configuration","text":"Configuration detailing how types are constructed and dependencies should be resolved can be provided as an associative array when instantiating Laminas\\Di\\Config . A type may be an actual class name or an alias to a class name. The configuration array respects the following keys (unknown keys are ignored): preferences : Associative nested array that maps class or interface names to a service name that should be used to provide a dependency. See the Type Preferences section below for details. types : Associative array defining how classes or aliases should be constructed. Each key in this array is a class or alias name, and its value is another associative array with the following keys: preferences : The same as preferences above, but only for the associated class. parameters : Associative array declaring the values to inject for the declared construction parameters. Each key is the parameter name as declared in the constructor method of the associated class name. See the Parameters section below for details. typeOf : String that contains a class name. It declares that the associated key is an alias of the given class name. This class must exist. It cannot be another alias. Below is an example of injector configuration. $config = new \\Laminas\\Di\\Config([ // Declares global preferences to use when resolving // dependencies of the specified type 'preferences' =&gt; [ // A map of classname =&gt; preferred type MyInterface::class =&gt; MyImplementation::class, ], // Declares how types should be constructed. // This also allows declaring aliases of a specific class 'types' =&gt; [ ClassName::class =&gt; [ // Declaration in the same way as global preferences // but these will apply when the type of the associated key // should be instantiated 'preferences' =&gt; [], // Constructor parameters to inject. This option will define // the injections directly by the parameter name of the constructor // used as key. // // If the parameter is type-hinted by a class/interface name, you can // provide the injection by string. The injector will use the IoC // container to obtain it. 'parameters' =&gt; [ 'foo' =&gt; 'bar', ], ], // Define an alias 'Alias.Name' =&gt; [ 'typeOf' =&gt; ClassName::class, 'preferences' =&gt; [], 'parameters' =&gt; [], ], ], ]);","title":"Configuration"},{"location":"v3/config/#type-preferences","text":"In many cases, you might be using interfaces as type hints as opposed to concrete types. Even though type preferences are not limited to interfaces or abstract class names, they provide hints to the injector on how such types should be resolved. The resolver will look up the name finally passed to the container in the following way (the first match will be used): The preference defined in the type configuration of the class if it satifies the typehint (implements, extends, or typeOf). If there is a global preference defined and it satisfies the typehint. Use the typehinted name directly. // Assume the following classes are declared: interface FooInterface {} class Foo implements FooInterface {} class SpecialFoo implements FooInterface {} class Bar {} class MyClass { public function __construct(FooInterface $foo) { // ... } } // With the following configuration: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'preferences' =&gt; [ FooInterface::class =&gt; Foo::class, ], 'types' =&gt; [ 'MyClass.A' =&gt; [ 'typeOf' =&gt; MyClass::class, 'preferences' =&gt; [ FooInterface::class =&gt; SpecialFoo::class, ], ], 'MyClass.B' =&gt; [ 'typeOf' =&gt; MyClass::class, 'preferences' =&gt; [ FooInterface::class =&gt; Bar::class, ], ], ], ])); // The results are: $a = $injector-&gt;create(MyClass::class); // Constructed with Foo $b = $injector-&gt;create('MyClass.A'); // Constructed with SpecialFoo $c = $injector-&gt;create('MyClass.B'); // Constructed with Foo (since Bar does not satisfy FooInterface)","title":"Type Preferences"},{"location":"v3/config/#parameters","text":"In contrast to type preferences, the resolver will not perform checks if the provided value satisfies the required type. It will be used directly to inject the value. There are several ways to define injections. An IoC container service name as string: This is only possible if the required type is a class or interface. For other types (scalars, iterable , callable , etc) or typeless parameters, the string value is passed as is . An instance of Laminas\\Di\\Resolver\\ValueInjection : Injects the value returned by getValue() as is. An instance of Laminas\\Di\\Resolver\\TypeInjection : Obtains the injected value from the IoC container by passing the return value of getType() to the container's get() method. The string literal '*' : This requests the injector to ignore any previously defined parameter and use the type preference resolution as described in Type Preferences . Any other value will be used as is and encapsulated in a Laminas\\Di\\Resolver\\ValueInjection . If the provided value's type does not fit the required parameter type, an exception is thrown.","title":"Parameters"},{"location":"v3/config/#aliases","text":"Aliases allow you to configure the same class with different construction options. Aliases can directly be created with the injector or declared as type preferences. An alias must refer to an actual class or an interface, therefore you cannot declare aliases for another alias. For example the following class should be instantiated in two different ways: // Assume the following classes are declared: class Foo {} class SpecialFoo extends Foo {} class MyClass { public function __construct(Foo $foo, string $bar) { // ... } } // With the following injection config: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'types' =&gt; [ MyClass::class =&gt; [ 'parameters' =&gt; [ 'foo' =&gt; SpecialFoo::class, 'bar' =&gt; 'Stringvalue', ], ], 'MyClass.Alias' =&gt; [ 'typeOf' =&gt; MyClass::class, 'parameters' =&gt; [ 'foo' =&gt; '*', 'bar' =&gt; 'Stringvalue', ], ], ], ])); // The results are: $a = $injector-&gt;create(MyClass::class); // Constructed with SpecialFoo $b = $injector-&gt;create('MyClass.Alias'); // Constructed with Foo (since there are no type preferences for Foo)","title":"Aliases"},{"location":"v3/injector/","text":"Injector The Laminas\\Di\\Injector is responsible for creating instances by providing the dependencies required by the class. The dependencies are resolved by analyzing the constructor parameters of the requested class via reflection. For parameters defined with a class or interface typehint, the configured preferences are taken into account. A Laminas\\Di\\ConfigInterface can be provided to configure the injector. See the Configuration chapter for details. Create instances Instances can be created by calling create() : use Laminas\\Di\\Injector; $injector = new Injector(); $injector-&gt;create(MyClass::class); Create instances with parameters You can also pass construction parameters when calling create: $injector-&gt;create(MyDbAdapter::class, [ 'username' =&gt; 'johndoe', ]); Parameters passed to create() will overwrite any configured injection for the requested class. Generally the following behavior applies for parameter values that are not ValueInjection or TypeInjection instances: If the parameter has a class/interface typehint: string values will be wrapped into a TypeInjection instance objects are wrapped into a ValueInjection instance everything else will fail with an exception. If the parameter has a scalar or pseudo-type typehint (e.g. string, int, iterable, callable, etc ...), the value will be wrapped in a ValueInjection . If the parameter has no typehint at all, the value will be wrapped into a ValueInjection . Examples // Assume the following classes class Foo {} class SpecialFoo extends Foo {} class Bar { public function __construct(Foo $foo, $type = null) {} } // Usage use Laminas\\Di\\Resolver\\ValueInjection; use Laminas\\Di\\Resolver\\TypeInjection; // Creates Bar with an instance of SpecialFoo from the IoC container: $injector-&gt;create(Bar::class, [ 'foo' =&gt; SpecialFoo::class, ]); // Creates Bar with the given instance of SpecialFoo bypassing the IoC // container: $injector-&gt;create(Bar::class, [ 'foo' =&gt; new ValueInjection(new SpecialFoo()), ]); // Creates Bar with an instance of Foo and the string literal 'SpecialFoo' for // $type: $injector-&gt;create(Bar::class, [ 'type' =&gt; SpecialFoo::class, ]); // Creates Bar with an instance of Foo and an instance of SpecialFoo from the // IoC container for $type: $injector-&gt;create(Bar::class, [ 'type' =&gt; new TypeInjection(SpecialFoo::class), ]); Refer to the Parameters section in the Configuration chapter for all possibilities of how parameters can be declared. Check if a type is creatable If you are uncertain whether or not the injector can create a specific type, you can test it with the canCreate() method. For example, if you were to consume the class name in a generic service factory for laminas-servicemanager: use Laminas\\Di\\Injector; /** @var \\Laminas\\ServiceManager\\ServiceManager $container */ $factory = function($container, $requestedName, array $options = null) { $injector = $container-&gt;get(Injector::class); if (! $injector-&gt;canCreate($requestedName)) { throw new \\RuntimeException('Bad service name'); } return $injector-&gt;create($requestedName, $options ?: []); }; $serviceManager-&gt;setFactory('Foo', $factory); $serviceManager-&gt;setFactory('Bar', $factory); $serviceManager-&gt;setFactory(stdClass::class, $factory);","title":"Injector"},{"location":"v3/injector/#injector","text":"The Laminas\\Di\\Injector is responsible for creating instances by providing the dependencies required by the class. The dependencies are resolved by analyzing the constructor parameters of the requested class via reflection. For parameters defined with a class or interface typehint, the configured preferences are taken into account. A Laminas\\Di\\ConfigInterface can be provided to configure the injector. See the Configuration chapter for details.","title":"Injector"},{"location":"v3/injector/#create-instances","text":"Instances can be created by calling create() : use Laminas\\Di\\Injector; $injector = new Injector(); $injector-&gt;create(MyClass::class);","title":"Create instances"},{"location":"v3/injector/#create-instances-with-parameters","text":"You can also pass construction parameters when calling create: $injector-&gt;create(MyDbAdapter::class, [ 'username' =&gt; 'johndoe', ]); Parameters passed to create() will overwrite any configured injection for the requested class. Generally the following behavior applies for parameter values that are not ValueInjection or TypeInjection instances: If the parameter has a class/interface typehint: string values will be wrapped into a TypeInjection instance objects are wrapped into a ValueInjection instance everything else will fail with an exception. If the parameter has a scalar or pseudo-type typehint (e.g. string, int, iterable, callable, etc ...), the value will be wrapped in a ValueInjection . If the parameter has no typehint at all, the value will be wrapped into a ValueInjection .","title":"Create instances with parameters"},{"location":"v3/injector/#check-if-a-type-is-creatable","text":"If you are uncertain whether or not the injector can create a specific type, you can test it with the canCreate() method. For example, if you were to consume the class name in a generic service factory for laminas-servicemanager: use Laminas\\Di\\Injector; /** @var \\Laminas\\ServiceManager\\ServiceManager $container */ $factory = function($container, $requestedName, array $options = null) { $injector = $container-&gt;get(Injector::class); if (! $injector-&gt;canCreate($requestedName)) { throw new \\RuntimeException('Bad service name'); } return $injector-&gt;create($requestedName, $options ?: []); }; $serviceManager-&gt;setFactory('Foo', $factory); $serviceManager-&gt;setFactory('Bar', $factory); $serviceManager-&gt;setFactory(stdClass::class, $factory);","title":"Check if a type is creatable"},{"location":"v3/installation/","text":"Installation This is only a placeholder. The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v3/installation/#installation","text":"This is only a placeholder. The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v3/intro/","text":"Introduction Dependency Injection Dependency Injection (here-in called DI) refers to the act of providing dependencies for an object during instantiation or via a method call. A basic example looks like this: $b = new MovieLister(new MovieFinder()); Above, MovieFinder is a dependency of MovieLister , and MovieFinder was injected into MovieLister . There are several forms of dependency injection: Constructor injection Setter injection Property (or field) injection While previous versions of laminas-di attempted to handle all three types, starting in version 3, the component focuses only on the first, constructor injection. This decision was made for several reasons: It simplified the implementation dramatically. The simplified implementation had performance benefits. It enforces the order of object initialization, which both helps to prevent circular dependencies, and ensures the completeness of the instantiated object. Further reading If you are not familiar with the concept of DI, here are several great reads: Matthew Weier O'Phinney's Analogy Fabien Potencier's Series on DI laminas-servicemanager Since laminas-di purely provides automatic DI (aka auto wiring), it does not provide code-driven Inversion of Control (IoC). However, Laminas does ship with another IoC component as well: laminas-servicemanager . Unlike laminas-di, laminas-servicemanager is code-driven, meaning that you tell it what class to instantiate, or provide a factory for the given class. This allows you more fine-grained control on how your objects will be instantiated. In fact laminas-di is designed to play nicely with other IoC containers that implement PSR-11, especially with laminas-servicemanager. You can even use factories generated by laminas-di for laminas-servicemanager. Dependency Injection Containers When your code is written in such a way that all your dependencies are injected into consuming objects, you might find that the simple act of wiring an object has gotten more complex. When this becomes the case, and you find that this wiring is creating more boilerplate code, this makes for an excellent opportunity to utilize a Dependency Injection Container. These containers are also often referred to as IoC Containers. In its simplest form, a Dependency Injection Container (here-in called a DiC for brevity) is an object that is capable of creating objects on request and managing the \"wiring\", or the injection of required dependencies, for those requested objects. Since the patterns that developers employ in writing DI capable code vary, DiC's are generally either in the form of smallish objects that suit a very specific pattern, or larger DiC frameworks. The PHP FIG defined a standard interface for such DiCs via PSR-11 (ContainerInterface) . laminas-di is a DiC framework which provides an injector performing the wiring, and a simple imlementation of a DiC. The injector is able to consume any PSR-11 container, such as laminas-servicemanager , to obtain the instances of the dependencies. While for the simplest use cases no configuration is needed, laminas-di allows developers to configure how to resolve dependencies for more complex use cases.","title":"Introduction"},{"location":"v3/intro/#introduction","text":"","title":"Introduction"},{"location":"v3/intro/#dependency-injection","text":"Dependency Injection (here-in called DI) refers to the act of providing dependencies for an object during instantiation or via a method call. A basic example looks like this: $b = new MovieLister(new MovieFinder()); Above, MovieFinder is a dependency of MovieLister , and MovieFinder was injected into MovieLister . There are several forms of dependency injection: Constructor injection Setter injection Property (or field) injection While previous versions of laminas-di attempted to handle all three types, starting in version 3, the component focuses only on the first, constructor injection. This decision was made for several reasons: It simplified the implementation dramatically. The simplified implementation had performance benefits. It enforces the order of object initialization, which both helps to prevent circular dependencies, and ensures the completeness of the instantiated object.","title":"Dependency Injection"},{"location":"v3/intro/#dependency-injection-containers","text":"When your code is written in such a way that all your dependencies are injected into consuming objects, you might find that the simple act of wiring an object has gotten more complex. When this becomes the case, and you find that this wiring is creating more boilerplate code, this makes for an excellent opportunity to utilize a Dependency Injection Container. These containers are also often referred to as IoC Containers. In its simplest form, a Dependency Injection Container (here-in called a DiC for brevity) is an object that is capable of creating objects on request and managing the \"wiring\", or the injection of required dependencies, for those requested objects. Since the patterns that developers employ in writing DI capable code vary, DiC's are generally either in the form of smallish objects that suit a very specific pattern, or larger DiC frameworks. The PHP FIG defined a standard interface for such DiCs via PSR-11 (ContainerInterface) . laminas-di is a DiC framework which provides an injector performing the wiring, and a simple imlementation of a DiC. The injector is able to consume any PSR-11 container, such as laminas-servicemanager , to obtain the instances of the dependencies. While for the simplest use cases no configuration is needed, laminas-di allows developers to configure how to resolve dependencies for more complex use cases.","title":"Dependency Injection Containers"},{"location":"v3/migration/","text":"Migration Guide Version 3 is the first new major release of laminas-di, and contains a number of backward incompatible changes. These were introduced to provide better performance, stability, and predictability. This guide describes how to migrate from Version 2 to 3. What has changed? This lists the most impacting changes and potential pitfalls when upgrading to laminas-di version 3. The injector now only supports constructor injections. If you require injections based on \"Aware\" interfaces or setter/method injections, you need to provide these on your own. You could do this by decorating the injector instance or using initializers in laminas-servicemanager. \\Laminas\\Di\\Di is renamed to \\Laminas\\Di\\InjectorInterface . It also is no longer an IoC container which offers get() / has() . Container functionality is now provided via Laminas\\Di\\DefaultContainer , which implements Psr\\Container\\ContainerInterface . If you were using \\Laminas\\Di\\Di as an IoC container, please switch to Laminas\\Di\\DefaultContainer or use it with laminas-servicemanager . All programmatic and array-based definitions were dropped. If you need custom definitions, implement \\Laminas\\Di\\Definition\\DefinitionInterface . The definition compiler was removed in favor of a code generator , which offers better performance. Added PHP 7.1 type safety. All interfaces and classes are strongly typed, and all methods use return typehints, as well as scalar typehints where needed. Generator and GeneratorInstance in Laminas\\Di\\ServiceLocator were removed in favor of the code generator , which creates laminas-servicemanager compatible factories. Migrating from v2 to v3 with laminas-mvc When you are using laminas-mvc, you can follow these steps to upgrade: Remove laminas/laminas-servicemanager-di from your composer.json , or execute composer remove laminas/laminas-servicemanager-di . Change the version constraint for laminas/laminas-di to ^3.0 , or execute composer require \"laminas/laminas-di:^3.0\" . Change any remaining module entries for Laminas\\ServiceManager\\Di\\Module to Laminas\\Di\\Module within either config/application.config.php or config/modules.config.php . If you are using any factories from laminas-servicemanager-di, you may have to replace them with Laminas\\Di\\Container\\AutowireFactory . Migrate your laminas-di config to the new configuration format . Migrating configuration laminas-di configuration is now expected in $config['dependencies']['auto'] , where $config is your config service. The laminas-di config service factory will automatically attempt to migrate legacy configurations at runtime, which gives you some time to migrate your configs. You can use Laminas\\Di\\LegacyConfig to help migrating existing configs: use Laminas\\Di\\LegacyConfig; $migrated = new LegacyConfig($diConfigArray); $code = var_export($migrated-&gt;toArray(), true); When the laminas-di config service factory is used to create configuration for use with the AutowireFactory and/or DefaultContainer , if it detects the $config['di'] key, it will emit an E_USER_DEPRECATED error, pointing to this documentation. We recommend using the above approach to convert your configuration to the format recognized by version 3.","title":"Migration from Version 2 to 3"},{"location":"v3/migration/#migration-guide","text":"Version 3 is the first new major release of laminas-di, and contains a number of backward incompatible changes. These were introduced to provide better performance, stability, and predictability. This guide describes how to migrate from Version 2 to 3.","title":"Migration Guide"},{"location":"v3/migration/#what-has-changed","text":"This lists the most impacting changes and potential pitfalls when upgrading to laminas-di version 3. The injector now only supports constructor injections. If you require injections based on \"Aware\" interfaces or setter/method injections, you need to provide these on your own. You could do this by decorating the injector instance or using initializers in laminas-servicemanager. \\Laminas\\Di\\Di is renamed to \\Laminas\\Di\\InjectorInterface . It also is no longer an IoC container which offers get() / has() . Container functionality is now provided via Laminas\\Di\\DefaultContainer , which implements Psr\\Container\\ContainerInterface . If you were using \\Laminas\\Di\\Di as an IoC container, please switch to Laminas\\Di\\DefaultContainer or use it with laminas-servicemanager . All programmatic and array-based definitions were dropped. If you need custom definitions, implement \\Laminas\\Di\\Definition\\DefinitionInterface . The definition compiler was removed in favor of a code generator , which offers better performance. Added PHP 7.1 type safety. All interfaces and classes are strongly typed, and all methods use return typehints, as well as scalar typehints where needed. Generator and GeneratorInstance in Laminas\\Di\\ServiceLocator were removed in favor of the code generator , which creates laminas-servicemanager compatible factories.","title":"What has changed?"},{"location":"v3/migration/#migrating-from-v2-to-v3-with-laminas-mvc","text":"When you are using laminas-mvc, you can follow these steps to upgrade: Remove laminas/laminas-servicemanager-di from your composer.json , or execute composer remove laminas/laminas-servicemanager-di . Change the version constraint for laminas/laminas-di to ^3.0 , or execute composer require \"laminas/laminas-di:^3.0\" . Change any remaining module entries for Laminas\\ServiceManager\\Di\\Module to Laminas\\Di\\Module within either config/application.config.php or config/modules.config.php . If you are using any factories from laminas-servicemanager-di, you may have to replace them with Laminas\\Di\\Container\\AutowireFactory . Migrate your laminas-di config to the new configuration format .","title":"Migrating from v2 to v3 with laminas-mvc"},{"location":"v3/migration/#migrating-configuration","text":"laminas-di configuration is now expected in $config['dependencies']['auto'] , where $config is your config service. The laminas-di config service factory will automatically attempt to migrate legacy configurations at runtime, which gives you some time to migrate your configs. You can use Laminas\\Di\\LegacyConfig to help migrating existing configs: use Laminas\\Di\\LegacyConfig; $migrated = new LegacyConfig($diConfigArray); $code = var_export($migrated-&gt;toArray(), true); When the laminas-di config service factory is used to create configuration for use with the AutowireFactory and/or DefaultContainer , if it detects the $config['di'] key, it will emit an E_USER_DEPRECATED error, pointing to this documentation. We recommend using the above approach to convert your configuration to the format recognized by version 3.","title":"Migrating configuration"},{"location":"v3/psr-11/","text":"PSR-11 Support laminas-di supports and implements PSR-11 ContainerInterface starting in version 3. It supports any implementation to obtain instances for resolved dependencies. laminas-di ships with a very basic implementation of the container interface which only uses the injector to create instances and always shares services it creates. We suggest you replace it with another implementation such as laminas-servicemanager for more flexibility.","title":"PSR-11 Support"},{"location":"v3/psr-11/#psr-11-support","text":"laminas-di supports and implements PSR-11 ContainerInterface starting in version 3. It supports any implementation to obtain instances for resolved dependencies. laminas-di ships with a very basic implementation of the container interface which only uses the injector to create instances and always shares services it creates. We suggest you replace it with another implementation such as laminas-servicemanager for more flexibility.","title":"PSR-11 Support"},{"location":"v3/quick-start/","text":"Quick Start The DI component provides an auto wiring strategy which implements constructor injection . It utilizes PSR-11 containers to obtain required services, so it can be paired with any IoC container that implements this interface, such as laminas-servicemanager . 1. Installation Before starting, make sure laminas-di is installed and configured . 2. Configuring the injector You can now create and configure an injector instance. The injector accepts an instance of Laminas\\Di\\ConfigInterface . This can be provided by passing Laminas\\Di\\Config , which accepts a PHP array to its constructor: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'preferences' =&gt; [ MyInterface::class =&gt; MyImplementation::class, ], ])); This config implementation accepts a variety of options. Refer to the Configuration chapter for full details. 3. Creating instances Finally, you can create new instances of a specific class or alias by using the create() method: $instance = $injector-&gt;create(MyClass::class); The only precondition is that the class you provide to create() must exist (or be autoloadable). If this is not the case, the injector will fail with an exception. The create() method will always create a new instance of the given class. If you need a shared instance, you can associate an IoC container implementing PSR-11 with the injector: $injector = new Injector($config, $container); $sharedInstance = $injector-&gt;getContainer()-&gt;get(MyClass::class); By default, the injector creates and uses an instance of Laminas\\Di\\DefaultContainer if no container is provided to it. This implementation is quite limited, however, and we recommend you use a more featureful container with the injector, such as laminas-servicemanager . Refer to the Usage with PSR-11 containers and Usage with laminas-servicemanager chapters for details.","title":"Quick Start"},{"location":"v3/quick-start/#quick-start","text":"The DI component provides an auto wiring strategy which implements constructor injection . It utilizes PSR-11 containers to obtain required services, so it can be paired with any IoC container that implements this interface, such as laminas-servicemanager .","title":"Quick Start"},{"location":"v3/quick-start/#1-installation","text":"Before starting, make sure laminas-di is installed and configured .","title":"1. Installation"},{"location":"v3/quick-start/#2-configuring-the-injector","text":"You can now create and configure an injector instance. The injector accepts an instance of Laminas\\Di\\ConfigInterface . This can be provided by passing Laminas\\Di\\Config , which accepts a PHP array to its constructor: use Laminas\\Di\\Injector; use Laminas\\Di\\Config; $injector = new Injector(new Config([ 'preferences' =&gt; [ MyInterface::class =&gt; MyImplementation::class, ], ])); This config implementation accepts a variety of options. Refer to the Configuration chapter for full details.","title":"2. Configuring the injector"},{"location":"v3/quick-start/#3-creating-instances","text":"Finally, you can create new instances of a specific class or alias by using the create() method: $instance = $injector-&gt;create(MyClass::class); The only precondition is that the class you provide to create() must exist (or be autoloadable). If this is not the case, the injector will fail with an exception. The create() method will always create a new instance of the given class. If you need a shared instance, you can associate an IoC container implementing PSR-11 with the injector: $injector = new Injector($config, $container); $sharedInstance = $injector-&gt;getContainer()-&gt;get(MyClass::class); By default, the injector creates and uses an instance of Laminas\\Di\\DefaultContainer if no container is provided to it. This implementation is quite limited, however, and we recommend you use a more featureful container with the injector, such as laminas-servicemanager . Refer to the Usage with PSR-11 containers and Usage with laminas-servicemanager chapters for details.","title":"3. Creating instances"},{"location":"v3/cookbook/aot-guide/","text":"Using AoT with Mezzio and laminas-servicemanager This guide will show you how you can use laminas-di's Ahead-of-Time (AoT) compiler to make your Mezzio application production ready when it uses laminas-di. You will learn how to: Add a script to run the compilation. Use the generated injector with laminas-servicemanager. Use the generated factories with laminas-servicemanager. 1. Create project and add laminas-di For this guide, we will use a mezzio application built from the skeleton with laminas-servicemanager as its IoC container. If you have already set up a project with laminas-di, you can skip this step. First, we'll create a new project: $ composer create-project mezzio/mezzio-skeleton laminas-di-aot-example Pick the components you want to use. We will be using laminas-servicemanager and a \"Modular\" layout for this example. Once you are done, enter the newly created project's working directory: $ cd laminas-di-aot-example Now add laminas-di with composer: $ composer require laminas/laminas-di Possible version conflicts Please make sure that laminas-di version 3.x is installed. When you are upgrading from laminas-di version 2.x, you may have to remove laminas-servicemanager-di because version 3.x makes this package obsolete and therefore conflicts with it. You can ensure version 3.x is installed by adding a version constraint to composer's require command: $ composer require laminas/laminas-di:^3.0 This approach will also notify you if there are conflicts with installing v3. Additional requirements for version 3.0.x Before version 3.1, laminas/laminas-code was required to be added individually to your project for generating AoT code. Since version 3.1 this is no longer necessary. The component installer should ask you where to inject the config provider. Pick option 1, which usually is config/config.php . If not, or you cannot use the component installer, you will need to add it manually by adding an entry for \\Laminas\\Di\\ConfigProvider::class within your application configuration example: // config/config.php: use Laminas\\ConfigAggregator\\ArrayProvider; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; // ... $aggregator = new ConfigAggregator([ // Add Laminas\\Di \\Laminas\\Di\\ConfigProvider::class, // ... ], $cacheConfig['config_cache_path']); // ... 2. Make your project ready for AoT To follow the modular principle of our mezzio app, we will put the AoT related configurations and generated code in a separate module called AppAoT . By default, skeleton applications include the mezzio-tooling component, which allows you to do this in a single step: $ ./vendor/bin/mezzio module:create AppAoT If the tooling is present and the above command is successful, you can now skip to the next step. Otherwise, continue on to manually create your module. First, create the initial directory structure: $ mkdir src/AppAoT/src Next, create a config provider class in src/AppAoT/src/ConfigProvider.php : namespace AppAoT; class ConfigProvider { public function __invoke() { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } public function getDependencies() { return [ 'auto' =&gt; [ 'aot' =&gt; [ 'namespace' =&gt; __NAMESPACE__ . '\\\\Generated', 'directory' =&gt; __DIR__ . '/../gen', ], ], ]; } } Add this new class to the the beginning of your config/config.php file's ConfigAggregator settings: $aggregator = new ConfigAggregator([ \\AppAoT\\ConfigProvider::class, // Add Laminas\\Di \\Laminas\\Di\\ConfigProvider::class, // ... ]); In order for your application to find this class, we need to add an autoloading rule. Find the psr-4 autoloader section of your composer.json , and add an entry for your new AppAot namespace as follows: { \"autoload\": { \"psr-4\": { \"App\\\\\": \"src/App/src/\", \"AppAoT\\\\\": \"src/AppAoT/src/\", \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\" } }, ... } Note that we defined AppAoT\\\\Generated\\\\ which will point to the code we generate from laminas-di in the next steps. Finally, update your autoloader: $ composer dump-autoload 3. Add some auto-wiring Because laminas-di can provide autowiring for us, we can remove configuration that already exists within our App module. Edit the file src/App/src/ConfigProvider.php and comment out the entries shown below: public function getDependencies() { return [ 'invokables' =&gt; [ // Action\\PingAction::class =&gt; Action\\PingAction::class, ], 'factories' =&gt; [ // Action\\HomePageAction::class =&gt; Action\\HomePageFactory::class, ], ]; } We can also now remove the HomePageFactory referenced in that method: $ rm src/App/src/HomePageFactory.php The default actions ( HomePageAction and PingAction ) now use auto wiring! 4. Add a code generator command script We will now add a simple script in the bin/ directory, which we will also add to our composer.json scripts section, to generate factories. In the real world, you might use a console implementation such as symfony/console for scripts such as these. Add the generator script bin/di-generate-aot.php : namespace AppAoT; use Psr\\Container\\ContainerInterface; use Laminas\\Code\\Scanner\\DirectoryScanner; use Laminas\\Di\\CodeGenerator\\InjectorGenerator; use Laminas\\Di\\Config; require __DIR__ . '/../vendor/autoload.php'; // Define the source directories to scan for classes for which // to generate AoT factories: $directories = [ __DIR__ . '/../src/App/src', ]; /** @var ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; $scanner = new DirectoryScanner($directories); $generator = $container-&gt;get(InjectorGenerator::class); $generator-&gt;generate($scanner-&gt;getClassNames()); Manually creating a generator instance Before version 3.1, no service factory existed for the generator. Below is an example demonstrating manual creation of the generator: namespace AppAoT; use Psr\\Container\\ContainerInterface; use Laminas\\Code\\Scanner\\DirectoryScanner; use Laminas\\Di\\CodeGenerator\\InjectorGenerator; use Laminas\\Di\\Config; use Laminas\\Di\\ConfigInterface; use Laminas\\Di\\Definition\\RuntimeDefinition; use Laminas\\Di\\Resolver\\DependencyResolver; require __DIR__ . '/../vendor/autoload.php'; $directories = [ __DIR__ . '/../src/App/src', ]; // Generator dependencies. You might put this in a service factory // in a real-life scenario. /** @var ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; $config = $container-&gt;get(ConfigInterface::class); $resolver = new DependencyResolver(new RuntimeDefinition(), $config); // This is important; we want to use configured aliases of the service manager. $resolver-&gt;setContainer($container); $scanner = new DirectoryScanner($directories); $generator = new InjectorGenerator($config, $resolver, __NAMESPACE__ . '\\Generated'); $generator-&gt;setOutputDirectory(__DIR__ . '/../src/AppAoT/gen'); $generator-&gt;generate($scanner-&gt;getClassNames()); To add the Composer script, edit composer.json and add the following to the scripts section: { \"scripts\": { \"di-generate-aot\": [ \"rm -vfr src/AppAoT/gen\", \"php bin/di-generate-aot.php\" ] } } When running the compiler with composer di-generate-aot , it will generate the following files: 5. Add AoT to the service manager Now we need to make the service manager use the AoT code. First, we'll use a delegator Laminas\\Di\\GeneratedInjectorDelegator to decorate the DI injector with the AoT version. Decorating the injector ensures that your factories that utilize Laminas\\Di\\Container\\AutowireFactory will benefit from AoT as well. We need to add configuration to the ConfigProvider class we created in step 2: Important: After this step, the application will always use the generated factories, if present. If you change any dependencies, you will need to run composer di-aot-generation again, or remove the generated code in src/AppAoT/gen/ and use runtime wiring. namespace AppAoT; use Laminas\\Di\\GeneratedInjectorDelegator; use Laminas\\Di\\InjectorInterface; class ConfigProvider { public function __invoke() { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } public function getDependencies() { return [ 'auto' =&gt; [ 'aot' =&gt; [ 'namespace' =&gt; __NAMESPACE__ . '\\\\Generated', 'directory' =&gt; __DIR__ . '/../gen', ], ], 'factories' =&gt; $this-&gt;getGeneratedFactories(), 'delegators' =&gt; [ InjectorInterface::class =&gt; [ GeneratedInjectorDelegator::class, ], ], ]; } private function getGeneratedFactories() { // The generated factories.php file is compatible with // laminas-servicemanager's factory configuration. // This avoids using the abstract AutowireFactory, which // improves performance a bit since we spare some lookups. if (file_exists(__DIR__ . '/../gen/factories.php')) { return include __DIR__ . '/../gen/factories.php'; } return []; } } Custom delegator factory (before version 3.2) The Laminas\\Di\\GeneratedInjectorDelegator class is available since version 3.2. For prior versions of laminas-di, a custom delegator factory must be provided. namespace AppAoT; use AppAoT\\Generated\\GeneratedInjector; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\Factory\\DelegatorFactoryInterface; class GeneratedInjectorDelegator implements DelegatorFactoryInterface { public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null) { $injector = $callback(); if (class_exists(GeneratedInjector::class)) { return new GeneratedInjector($injector); } return $injector; } }","title":"Using AoT with Mezzio and laminas-servicemanager"},{"location":"v3/cookbook/aot-guide/#using-aot-with-mezzio-and-laminas-servicemanager","text":"This guide will show you how you can use laminas-di's Ahead-of-Time (AoT) compiler to make your Mezzio application production ready when it uses laminas-di. You will learn how to: Add a script to run the compilation. Use the generated injector with laminas-servicemanager. Use the generated factories with laminas-servicemanager.","title":"Using AoT with Mezzio and laminas-servicemanager"},{"location":"v3/cookbook/aot-guide/#1-create-project-and-add-laminas-di","text":"For this guide, we will use a mezzio application built from the skeleton with laminas-servicemanager as its IoC container. If you have already set up a project with laminas-di, you can skip this step. First, we'll create a new project: $ composer create-project mezzio/mezzio-skeleton laminas-di-aot-example Pick the components you want to use. We will be using laminas-servicemanager and a \"Modular\" layout for this example. Once you are done, enter the newly created project's working directory: $ cd laminas-di-aot-example Now add laminas-di with composer: $ composer require laminas/laminas-di","title":"1. Create project and add laminas-di"},{"location":"v3/cookbook/aot-guide/#2-make-your-project-ready-for-aot","text":"To follow the modular principle of our mezzio app, we will put the AoT related configurations and generated code in a separate module called AppAoT . By default, skeleton applications include the mezzio-tooling component, which allows you to do this in a single step: $ ./vendor/bin/mezzio module:create AppAoT If the tooling is present and the above command is successful, you can now skip to the next step. Otherwise, continue on to manually create your module. First, create the initial directory structure: $ mkdir src/AppAoT/src Next, create a config provider class in src/AppAoT/src/ConfigProvider.php : namespace AppAoT; class ConfigProvider { public function __invoke() { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } public function getDependencies() { return [ 'auto' =&gt; [ 'aot' =&gt; [ 'namespace' =&gt; __NAMESPACE__ . '\\\\Generated', 'directory' =&gt; __DIR__ . '/../gen', ], ], ]; } } Add this new class to the the beginning of your config/config.php file's ConfigAggregator settings: $aggregator = new ConfigAggregator([ \\AppAoT\\ConfigProvider::class, // Add Laminas\\Di \\Laminas\\Di\\ConfigProvider::class, // ... ]); In order for your application to find this class, we need to add an autoloading rule. Find the psr-4 autoloader section of your composer.json , and add an entry for your new AppAot namespace as follows: { \"autoload\": { \"psr-4\": { \"App\\\\\": \"src/App/src/\", \"AppAoT\\\\\": \"src/AppAoT/src/\", \"AppAoT\\\\Generated\\\\\": \"src/AppAoT/gen/\" } }, ... } Note that we defined AppAoT\\\\Generated\\\\ which will point to the code we generate from laminas-di in the next steps. Finally, update your autoloader: $ composer dump-autoload","title":"2. Make your project ready for AoT"},{"location":"v3/cookbook/aot-guide/#3-add-some-auto-wiring","text":"Because laminas-di can provide autowiring for us, we can remove configuration that already exists within our App module. Edit the file src/App/src/ConfigProvider.php and comment out the entries shown below: public function getDependencies() { return [ 'invokables' =&gt; [ // Action\\PingAction::class =&gt; Action\\PingAction::class, ], 'factories' =&gt; [ // Action\\HomePageAction::class =&gt; Action\\HomePageFactory::class, ], ]; } We can also now remove the HomePageFactory referenced in that method: $ rm src/App/src/HomePageFactory.php The default actions ( HomePageAction and PingAction ) now use auto wiring!","title":"3. Add some auto-wiring"},{"location":"v3/cookbook/aot-guide/#4-add-a-code-generator-command-script","text":"We will now add a simple script in the bin/ directory, which we will also add to our composer.json scripts section, to generate factories. In the real world, you might use a console implementation such as symfony/console for scripts such as these. Add the generator script bin/di-generate-aot.php : namespace AppAoT; use Psr\\Container\\ContainerInterface; use Laminas\\Code\\Scanner\\DirectoryScanner; use Laminas\\Di\\CodeGenerator\\InjectorGenerator; use Laminas\\Di\\Config; require __DIR__ . '/../vendor/autoload.php'; // Define the source directories to scan for classes for which // to generate AoT factories: $directories = [ __DIR__ . '/../src/App/src', ]; /** @var ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; $scanner = new DirectoryScanner($directories); $generator = $container-&gt;get(InjectorGenerator::class); $generator-&gt;generate($scanner-&gt;getClassNames());","title":"4. Add a code generator command script"},{"location":"v3/cookbook/aot-guide/#5-add-aot-to-the-service-manager","text":"Now we need to make the service manager use the AoT code. First, we'll use a delegator Laminas\\Di\\GeneratedInjectorDelegator to decorate the DI injector with the AoT version. Decorating the injector ensures that your factories that utilize Laminas\\Di\\Container\\AutowireFactory will benefit from AoT as well. We need to add configuration to the ConfigProvider class we created in step 2: Important: After this step, the application will always use the generated factories, if present. If you change any dependencies, you will need to run composer di-aot-generation again, or remove the generated code in src/AppAoT/gen/ and use runtime wiring. namespace AppAoT; use Laminas\\Di\\GeneratedInjectorDelegator; use Laminas\\Di\\InjectorInterface; class ConfigProvider { public function __invoke() { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), ]; } public function getDependencies() { return [ 'auto' =&gt; [ 'aot' =&gt; [ 'namespace' =&gt; __NAMESPACE__ . '\\\\Generated', 'directory' =&gt; __DIR__ . '/../gen', ], ], 'factories' =&gt; $this-&gt;getGeneratedFactories(), 'delegators' =&gt; [ InjectorInterface::class =&gt; [ GeneratedInjectorDelegator::class, ], ], ]; } private function getGeneratedFactories() { // The generated factories.php file is compatible with // laminas-servicemanager's factory configuration. // This avoids using the abstract AutowireFactory, which // improves performance a bit since we spare some lookups. if (file_exists(__DIR__ . '/../gen/factories.php')) { return include __DIR__ . '/../gen/factories.php'; } return []; } }","title":"5. Add AoT to the service manager"},{"location":"v3/cookbook/use-with-psr-containers/","text":"Usage with PSR-11 containers laminas-di is designed to utilize and work with any IoC container that implements the PSR-11 Psr\\Container\\ContainerInterface . To achieve this you can pass any container instance as the second parameter to the injector: use Laminas\\Di\\Injector; $injector = new Injector(null, $container); From that point forwards, the injector will use the provided $container to obtain the dependencies. Decorating the container In the example above, the provided container may not utilize the injector to create unknown instances, even when the classes are known to laminas-di. It may fail with an exception that dependencies could not be resolved. If you want to pair the container with the injector and use the injector for dependencies the container is not aware of, you may decorate the original container into a laminas-di-aware implementation. As an example: namespace MyApp; use Laminas\\Di\\Injector; use Psr\\Container\\ContainerInterface; class MyContainer implements ContainerInterface { private $container; private $injector; public function __construct(ContainerInterface $wrappedContainer) { $this-&gt;container = $wrappedContainer; $this-&gt;injector = new Injector(null, $this); } public function has($name) { return $this-&gt;container-&gt;has($name) || $this-&gt;injector-&gt;canCreate($name); } public function get($name) { if ($this-&gt;container-&gt;has($name)) { return $this-&gt;container-&gt;get($name); } $service = $this-&gt;injector-&gt;create($name); // You might make the service shared via the decorated container // as well: // $this-&gt;container-&gt;set($name, $service); return $service; } }","title":"Usage with PSR-11 Containers"},{"location":"v3/cookbook/use-with-psr-containers/#usage-with-psr-11-containers","text":"laminas-di is designed to utilize and work with any IoC container that implements the PSR-11 Psr\\Container\\ContainerInterface . To achieve this you can pass any container instance as the second parameter to the injector: use Laminas\\Di\\Injector; $injector = new Injector(null, $container); From that point forwards, the injector will use the provided $container to obtain the dependencies.","title":"Usage with PSR-11 containers"},{"location":"v3/cookbook/use-with-psr-containers/#decorating-the-container","text":"In the example above, the provided container may not utilize the injector to create unknown instances, even when the classes are known to laminas-di. It may fail with an exception that dependencies could not be resolved. If you want to pair the container with the injector and use the injector for dependencies the container is not aware of, you may decorate the original container into a laminas-di-aware implementation. As an example: namespace MyApp; use Laminas\\Di\\Injector; use Psr\\Container\\ContainerInterface; class MyContainer implements ContainerInterface { private $container; private $injector; public function __construct(ContainerInterface $wrappedContainer) { $this-&gt;container = $wrappedContainer; $this-&gt;injector = new Injector(null, $this); } public function has($name) { return $this-&gt;container-&gt;has($name) || $this-&gt;injector-&gt;canCreate($name); } public function get($name) { if ($this-&gt;container-&gt;has($name)) { return $this-&gt;container-&gt;get($name); } $service = $this-&gt;injector-&gt;create($name); // You might make the service shared via the decorated container // as well: // $this-&gt;container-&gt;set($name, $service); return $service; } }","title":"Decorating the container"},{"location":"v3/cookbook/use-with-servicemanager/","text":"Usage With laminas-servicemanager laminas-di is designed to play and integrate well with laminas-servicemanager. When you are using laminas-component-installer , you just need to install laminas-di via composer and you're done. Service Factories For DI instances laminas-di ships with two service factories to provide the Laminas\\Di\\InjectorInterface implementation. Laminas\\Di\\Container\\ConfigFactory : Creates a config instance by using the \"config\" service. Laminas\\Di\\Container\\InjectorFactory : Creates the injector instance that uses a Laminas\\Di\\ConfigInterface service, if available. use Laminas\\Di; use Laminas\\Di\\Container; $serviceManager-&gt;setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class); $serviceManager-&gt;setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class); Abstract/Generic Service Factory This component ships with a generic factory Laminas\\Di\\Container\\AutowireFactory . This factory is suitable as an abstract service factory for use with laminas-servicemanager. You can also use it to create instances with laminas-di using an IoC container (e.g. inside a service factory): use Laminas\\Di\\Container\\AutowireFactory; (new AutowireFactory())-&gt;__invoke($container, MyClassname::class); Or you can use it as factory in your service configuration directly: return [ 'factories' =&gt; [ SomeClass::class =&gt; \\Laminas\\Di\\Container\\AutowireFactory::class, ], ]; Service Factory For AoT Code Generation laminas-di also provides a factory for Laminas\\Di\\CodeGenerator\\InjectorGenerator . This factory ( Laminas\\Di\\Container\\GeneratorFactory ) is also auto registered by the Module and ConfigProvider classes for laminas-mvc and Mezzio.","title":"Usage with laminas-servicemanager"},{"location":"v3/cookbook/use-with-servicemanager/#usage-with-laminas-servicemanager","text":"laminas-di is designed to play and integrate well with laminas-servicemanager. When you are using laminas-component-installer , you just need to install laminas-di via composer and you're done.","title":"Usage With laminas-servicemanager"},{"location":"v3/cookbook/use-with-servicemanager/#service-factories-for-di-instances","text":"laminas-di ships with two service factories to provide the Laminas\\Di\\InjectorInterface implementation. Laminas\\Di\\Container\\ConfigFactory : Creates a config instance by using the \"config\" service. Laminas\\Di\\Container\\InjectorFactory : Creates the injector instance that uses a Laminas\\Di\\ConfigInterface service, if available. use Laminas\\Di; use Laminas\\Di\\Container; $serviceManager-&gt;setFactory(Di\\ConfigInterface::class, Container\\ConfigFactory::class); $serviceManager-&gt;setFactory(Di\\InjectorInterface::class, Container\\InjectorFactory::class);","title":"Service Factories For DI instances"},{"location":"v3/cookbook/use-with-servicemanager/#abstractgeneric-service-factory","text":"This component ships with a generic factory Laminas\\Di\\Container\\AutowireFactory . This factory is suitable as an abstract service factory for use with laminas-servicemanager. You can also use it to create instances with laminas-di using an IoC container (e.g. inside a service factory): use Laminas\\Di\\Container\\AutowireFactory; (new AutowireFactory())-&gt;__invoke($container, MyClassname::class); Or you can use it as factory in your service configuration directly: return [ 'factories' =&gt; [ SomeClass::class =&gt; \\Laminas\\Di\\Container\\AutowireFactory::class, ], ];","title":"Abstract/Generic Service Factory"},{"location":"v3/cookbook/use-with-servicemanager/#service-factory-for-aot-code-generation","text":"laminas-di also provides a factory for Laminas\\Di\\CodeGenerator\\InjectorGenerator . This factory ( Laminas\\Di\\Container\\GeneratorFactory ) is also auto registered by the Module and ConfigProvider classes for laminas-mvc and Mezzio.","title":"Service Factory For AoT Code Generation"}]}